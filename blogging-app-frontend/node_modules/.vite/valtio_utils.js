import {
  a,
  i,
  proxy,
  ref,
  snapshot,
  subscribe
} from "./chunk-XOCYC32V.js";
import "./chunk-A5ICIBVI.js";

// node_modules/valtio/esm/utils.js
var subscribeKey = (proxyObject, key, callback, notifyInSync) => subscribe(proxyObject, (ops) => {
  if (ops.some((op) => op[1][0] === key)) {
    callback(proxyObject[key]);
  }
}, notifyInSync);
var devtools = (proxyObject, name) => {
  let extension;
  try {
    extension = window.__REDUX_DEVTOOLS_EXTENSION__;
  } catch {
  }
  if (!extension) {
    if (typeof process === "object" && true && typeof window !== "undefined") {
      console.warn("[Warning] Please install/enable Redux devtools extension");
    }
    return;
  }
  let isTimeTraveling = false;
  const devtools2 = extension.connect({ name });
  const unsub1 = subscribe(proxyObject, () => {
    if (isTimeTraveling) {
      isTimeTraveling = false;
    } else {
      devtools2.send(`Update - ${new Date().toLocaleString()}`, snapshot(proxyObject));
    }
  });
  const unsub2 = devtools2.subscribe((message) => {
    var _a, _b, _c, _d, _e, _f;
    if (message.type === "DISPATCH" && message.state) {
      if (((_a = message.payload) == null ? void 0 : _a.type) === "JUMP_TO_ACTION" || ((_b = message.payload) == null ? void 0 : _b.type) === "JUMP_TO_STATE") {
        isTimeTraveling = true;
      }
      const nextValue = JSON.parse(message.state);
      Object.keys(nextValue).forEach((key) => {
        proxyObject[key] = nextValue[key];
      });
    } else if (message.type === "DISPATCH" && ((_c = message.payload) == null ? void 0 : _c.type) === "COMMIT") {
      devtools2.init(snapshot(proxyObject));
    } else if (message.type === "DISPATCH" && ((_d = message.payload) == null ? void 0 : _d.type) === "IMPORT_STATE") {
      const actions = (_e = message.payload.nextLiftedState) == null ? void 0 : _e.actionsById;
      const computedStates = ((_f = message.payload.nextLiftedState) == null ? void 0 : _f.computedStates) || [];
      isTimeTraveling = true;
      computedStates.forEach(({ state }, index) => {
        const action = actions[index] || `Update - ${new Date().toLocaleString()}`;
        Object.keys(state).forEach((key) => {
          proxyObject[key] = state[key];
        });
        if (index === 0) {
          devtools2.init(snapshot(proxyObject));
        } else {
          devtools2.send(action, snapshot(proxyObject));
        }
      });
    }
  });
  devtools2.init(snapshot(proxyObject));
  return () => {
    unsub1();
    unsub2();
  };
};
var addComputed = (proxyObject, computedFns, targetObject = proxyObject) => {
  Object.keys(computedFns).forEach((key) => {
    if (Object.getOwnPropertyDescriptor(targetObject, key)) {
      throw new Error("object property already defined");
    }
    const get = computedFns[key];
    let prevSnapshot;
    let affected = new WeakMap();
    let pending = false;
    const callback = () => {
      const nextSnapshot = snapshot(proxyObject);
      if (!pending && (!prevSnapshot || a(prevSnapshot, nextSnapshot, affected))) {
        affected = new WeakMap();
        const value = get(i(nextSnapshot, affected));
        prevSnapshot = nextSnapshot;
        if (value instanceof Promise) {
          pending = true;
          value.then((v) => {
            targetObject[key] = v;
          }).catch((e) => {
            targetObject[key] = new Proxy({}, {
              get() {
                throw e;
              }
            });
          }).finally(() => {
            pending = false;
          });
        }
        targetObject[key] = value;
      }
    };
    subscribe(proxyObject, callback);
    callback();
  });
};
var proxyWithComputed = (initialObject, computedFns) => {
  Object.keys(computedFns).forEach((key) => {
    if (Object.getOwnPropertyDescriptor(initialObject, key)) {
      throw new Error("object property already defined");
    }
    const computedFn = computedFns[key];
    const { get, set } = typeof computedFn === "function" ? { get: computedFn } : computedFn;
    let computedValue;
    let prevSnapshot;
    let affected = new WeakMap();
    const desc = {};
    desc.get = () => {
      const nextSnapshot = snapshot(proxyObject);
      if (!prevSnapshot || a(prevSnapshot, nextSnapshot, affected)) {
        affected = new WeakMap();
        computedValue = get(i(nextSnapshot, affected));
        prevSnapshot = nextSnapshot;
      }
      return computedValue;
    };
    if (set) {
      desc.set = (newValue) => set(proxyObject, newValue);
    }
    Object.defineProperty(initialObject, key, desc);
  });
  const proxyObject = proxy(initialObject);
  return proxyObject;
};
var currentCleanups;
var watch = (callback) => {
  const cleanups = new Set();
  const subscriptions = new Set();
  let alive = true;
  const cleanup = () => {
    cleanups.forEach((clean) => {
      clean();
    });
    cleanups.clear();
    subscriptions.clear();
  };
  const revalidate = () => {
    if (!alive) {
      return;
    }
    cleanup();
    const parent = currentCleanups;
    currentCleanups = cleanups;
    try {
      const cleanupReturn = callback((proxy2) => {
        subscriptions.add(proxy2);
        return proxy2;
      });
      if (cleanupReturn) {
        cleanups.add(cleanupReturn);
      }
    } finally {
      currentCleanups = parent;
    }
    subscriptions.forEach((proxy2) => {
      const clean = subscribe(proxy2, revalidate);
      cleanups.add(clean);
    });
  };
  const wrappedCleanup = () => {
    if (alive) {
      cleanup();
      alive = false;
    }
  };
  if (currentCleanups) {
    currentCleanups.add(wrappedCleanup);
  }
  revalidate();
  return wrappedCleanup;
};
var proxyWithHistory = (initialValue) => {
  const proxyObject = proxy({
    value: initialValue,
    history: ref({
      wip: initialValue,
      snapshots: [],
      index: -1
    }),
    canUndo: () => proxyObject.history.index > 0,
    undo: () => {
      if (proxyObject.canUndo()) {
        proxyObject.value = proxyObject.history.wip = proxyObject.history.snapshots[--proxyObject.history.index];
      }
    },
    canRedo: () => proxyObject.history.index < proxyObject.history.snapshots.length - 1,
    redo: () => {
      if (proxyObject.canRedo()) {
        proxyObject.value = proxyObject.history.wip = proxyObject.history.snapshots[++proxyObject.history.index];
      }
    },
    saveHistory: () => {
      proxyObject.history.snapshots.splice(proxyObject.history.index + 1);
      proxyObject.history.snapshots.push(snapshot(proxyObject).value);
      ++proxyObject.history.index;
    }
  });
  subscribe(proxyObject, (ops) => {
    if (ops.some((op) => op[1][0] === "value" && (op[0] !== "set" || op[2] !== proxyObject.history.wip))) {
      proxyObject.saveHistory();
    }
  });
  return proxyObject;
};
export {
  addComputed,
  devtools,
  proxyWithComputed,
  proxyWithHistory,
  subscribeKey,
  watch
};
//# sourceMappingURL=valtio_utils.js.map
