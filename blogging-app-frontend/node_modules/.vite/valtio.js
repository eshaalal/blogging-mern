import {
  a,
  g,
  getVersion,
  i,
  proxy,
  ref,
  snapshot,
  subscribe
} from "./chunk-XOCYC32V.js";
import {
  require_react
} from "./chunk-RYO6GA3P.js";
import {
  __toModule
} from "./chunk-A5ICIBVI.js";

// node_modules/valtio/esm/index.js
var import_react = __toModule(require_react());
var TARGET = Symbol();
var GET_VERSION = Symbol();
var createMutableSource = (target, getVersion2) => ({
  [TARGET]: target,
  [GET_VERSION]: getVersion2
});
var useMutableSource = (source, getSnapshot, subscribe2) => {
  const lastVersion = (0, import_react.useRef)(0);
  const currentVersion = source[GET_VERSION](source[TARGET]);
  const [state, setState] = (0, import_react.useState)(() => [
    source,
    getSnapshot,
    subscribe2,
    currentVersion,
    getSnapshot(source[TARGET])
  ]);
  let currentSnapshot = state[4];
  if (state[0] !== source || state[1] !== getSnapshot || state[2] !== subscribe2) {
    currentSnapshot = getSnapshot(source[TARGET]);
    setState([
      source,
      getSnapshot,
      subscribe2,
      currentVersion,
      currentSnapshot
    ]);
  } else if (currentVersion !== state[3] && currentVersion !== lastVersion.current) {
    currentSnapshot = getSnapshot(source[TARGET]);
    if (!Object.is(currentSnapshot, state[4])) {
      setState([
        source,
        getSnapshot,
        subscribe2,
        currentVersion,
        currentSnapshot
      ]);
    }
  }
  (0, import_react.useEffect)(() => {
    let didUnsubscribe = false;
    const checkForUpdates = () => {
      if (didUnsubscribe) {
        return;
      }
      try {
        const nextSnapshot = getSnapshot(source[TARGET]);
        const nextVersion = source[GET_VERSION](source[TARGET]);
        lastVersion.current = nextVersion;
        setState((prev) => {
          if (prev[0] !== source || prev[1] !== getSnapshot || prev[2] !== subscribe2) {
            return prev;
          }
          if (Object.is(prev[4], nextSnapshot)) {
            return prev;
          }
          return [
            prev[0],
            prev[1],
            prev[2],
            nextVersion,
            nextSnapshot
          ];
        });
      } catch (e) {
        setState((prev) => [...prev]);
      }
    };
    const unsubscribe = subscribe2(source[TARGET], checkForUpdates);
    checkForUpdates();
    return () => {
      didUnsubscribe = true;
      unsubscribe();
    };
  }, [source, getSnapshot, subscribe2]);
  return currentSnapshot;
};
var isSSR = typeof window === "undefined" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent);
var useIsomorphicLayoutEffect = isSSR ? import_react.useEffect : import_react.useLayoutEffect;
var useAffectedDebugValue = (state, affected) => {
  const pathList = (0, import_react.useRef)();
  (0, import_react.useEffect)(() => {
    pathList.current = g(state, affected);
  });
  (0, import_react.useDebugValue)(pathList.current);
};
var mutableSourceCache = new WeakMap();
var getMutableSource = (proxyObject) => {
  if (!mutableSourceCache.has(proxyObject)) {
    mutableSourceCache.set(proxyObject, createMutableSource(proxyObject, getVersion));
  }
  return mutableSourceCache.get(proxyObject);
};
var useSnapshot = (proxyObject, options) => {
  const forceUpdate = (0, import_react.useReducer)((c) => c + 1, 0)[1];
  const affected = new WeakMap();
  const lastAffected = (0, import_react.useRef)();
  const prevSnapshot = (0, import_react.useRef)();
  const lastSnapshot = (0, import_react.useRef)();
  useIsomorphicLayoutEffect(() => {
    lastSnapshot.current = prevSnapshot.current = snapshot(proxyObject);
  }, [proxyObject]);
  useIsomorphicLayoutEffect(() => {
    lastAffected.current = affected;
    if (prevSnapshot.current !== lastSnapshot.current && a(prevSnapshot.current, lastSnapshot.current, affected, new WeakMap())) {
      prevSnapshot.current = lastSnapshot.current;
      forceUpdate();
    }
  });
  const notifyInSync = options == null ? void 0 : options.sync;
  const sub = (0, import_react.useCallback)((proxyObject2, cb) => subscribe(proxyObject2, () => {
    const nextSnapshot = snapshot(proxyObject2);
    lastSnapshot.current = nextSnapshot;
    try {
      if (lastAffected.current && !a(prevSnapshot.current, nextSnapshot, lastAffected.current, new WeakMap())) {
        return;
      }
    } catch (e) {
    }
    prevSnapshot.current = nextSnapshot;
    cb();
  }, notifyInSync), [notifyInSync]);
  const currSnapshot = useMutableSource(getMutableSource(proxyObject), snapshot, sub);
  if (typeof process === "object" && true) {
    useAffectedDebugValue(currSnapshot, affected);
  }
  const proxyCache = (0, import_react.useMemo)(() => new WeakMap(), []);
  return i(currSnapshot, affected, proxyCache);
};
export {
  getVersion,
  proxy,
  ref,
  snapshot,
  subscribe,
  useSnapshot
};
//# sourceMappingURL=valtio.js.map
