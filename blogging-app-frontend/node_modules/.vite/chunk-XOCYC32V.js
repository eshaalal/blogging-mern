// node_modules/proxy-compare/dist/index.modern.js
var e = Symbol();
var t = Symbol();
var r = Symbol();
var n = Object.getPrototypeOf;
var o = new WeakMap();
var s = (e2) => e2 && (o.has(e2) ? o.get(e2) : n(e2) === Object.prototype || n(e2) === Array.prototype);
var c = (e2) => typeof e2 == "object" && e2 !== null;
var l = (n2, o2) => {
  let s2 = false;
  const c2 = (e2, t2) => {
    if (!s2) {
      let r2 = e2.a.get(n2);
      r2 || (r2 = new Set(), e2.a.set(n2, r2)), r2.add(t2);
    }
  }, l2 = { f: o2, get(e2, t2) {
    return t2 === r ? n2 : (c2(this, t2), i(e2[t2], this.a, this.c));
  }, has(e2, r2) {
    return r2 === t ? (s2 = true, this.a.delete(n2), true) : (c2(this, r2), r2 in e2);
  }, ownKeys(t2) {
    return c2(this, e), Reflect.ownKeys(t2);
  } };
  return o2 && (l2.set = l2.deleteProperty = () => false), l2;
};
var i = (e2, t2, o2) => {
  if (!s(e2))
    return e2;
  const c2 = e2[r] || e2, i2 = ((e3) => Object.isFrozen(e3) || Object.values(Object.getOwnPropertyDescriptors(e3)).some((e4) => !e4.writable))(c2);
  let u2 = o2 && o2.get(c2);
  return u2 && u2.f === i2 || (u2 = l(c2, i2), u2.p = new Proxy(i2 ? ((e3) => {
    if (Array.isArray(e3))
      return Array.from(e3);
    const t3 = Object.getOwnPropertyDescriptors(e3);
    return Object.values(t3).forEach((e4) => {
      e4.configurable = true;
    }), Object.create(n(e3), t3);
  })(c2) : c2, u2), o2 && o2.set(c2, u2)), u2.a = t2, u2.c = o2, u2.p;
};
var u = (e2, t2) => {
  const r2 = Reflect.ownKeys(e2), n2 = Reflect.ownKeys(t2);
  return r2.length !== n2.length || r2.some((e3, t3) => e3 !== n2[t3]);
};
var a = (t2, r2, n2, o2) => {
  if (Object.is(t2, r2))
    return false;
  if (!c(t2) || !c(r2))
    return true;
  const s2 = n2.get(t2);
  if (!s2)
    return true;
  if (o2) {
    const e2 = o2.get(t2);
    if (e2 && e2.n === r2)
      return e2.g;
    o2.set(t2, { n: r2, g: false });
  }
  let l2 = null;
  for (const c2 of s2) {
    const s3 = c2 === e ? u(t2, r2) : a(t2[c2], r2[c2], n2, o2);
    if (s3 !== true && s3 !== false || (l2 = s3), l2)
      break;
  }
  return l2 === null && (l2 = true), o2 && o2.set(t2, { n: r2, g: l2 }), l2;
};
var y = (e2) => s(e2) && e2[r] || null;
var b = (e2, t2 = true) => {
  o.set(e2, t2);
};
var g = (e2, t2) => {
  const r2 = [], n2 = (e3, o2) => {
    const s2 = t2.get(e3);
    s2 ? s2.forEach((t3) => {
      n2(e3[t3], o2 ? [...o2, t3] : [t3]);
    }) : o2 && r2.push(o2);
  };
  return n2(e2), r2;
};

// node_modules/valtio/esm/vanilla.js
var VERSION = Symbol();
var LISTENERS = Symbol();
var SNAPSHOT = Symbol();
var PROMISE_RESULT = Symbol();
var PROMISE_ERROR = Symbol();
var refSet = new WeakSet();
var ref = (o2) => {
  refSet.add(o2);
  return o2;
};
var isSupportedObject = (x) => typeof x === "object" && x !== null && (Array.isArray(x) || !x[Symbol.iterator]) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer);
var proxyCache = new WeakMap();
var globalVersion = 1;
var snapshotCache = new WeakMap();
var proxy = (initialObject = {}) => {
  if (!isSupportedObject(initialObject)) {
    throw new Error("unsupported object type");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = globalVersion;
  const listeners = new Set();
  const notifyUpdate = (op, nextVersion) => {
    if (!nextVersion) {
      nextVersion = ++globalVersion;
    }
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  const propListeners = new Map();
  const getPropListener = (prop) => {
    let propListener = propListeners.get(prop);
    if (!propListener) {
      propListener = (op, nextVersion) => {
        const newOp = [...op];
        newOp[1] = [prop, ...newOp[1]];
        notifyUpdate(newOp, nextVersion);
      };
      propListeners.set(prop, propListener);
    }
    return propListener;
  };
  const popPropListener = (prop) => {
    const propListener = propListeners.get(prop);
    propListeners.delete(prop);
    return propListener;
  };
  const createSnapshot = (target, receiver) => {
    const cache = snapshotCache.get(receiver);
    if ((cache == null ? void 0 : cache[0]) === version) {
      return cache[1];
    }
    const snapshot2 = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
    b(snapshot2, true);
    snapshotCache.set(receiver, [version, snapshot2]);
    Reflect.ownKeys(target).forEach((key) => {
      const value = target[key];
      if (refSet.has(value)) {
        b(value, false);
        snapshot2[key] = value;
      } else if (!isSupportedObject(value)) {
        snapshot2[key] = value;
      } else if (value instanceof Promise) {
        if (PROMISE_RESULT in value) {
          snapshot2[key] = value[PROMISE_RESULT];
        } else {
          const errorOrPromise = value[PROMISE_ERROR] || value;
          Object.defineProperty(snapshot2, key, {
            get() {
              throw errorOrPromise;
            }
          });
        }
      } else if (value[VERSION]) {
        snapshot2[key] = value[SNAPSHOT];
      } else {
        snapshot2[key] = value;
      }
    });
    Object.freeze(snapshot2);
    return snapshot2;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const proxyObject = new Proxy(baseObject, {
    get(target, prop, receiver) {
      if (prop === VERSION) {
        return version;
      }
      if (prop === LISTENERS) {
        return listeners;
      }
      if (prop === SNAPSHOT) {
        return createSnapshot(target, receiver);
      }
      return target[prop];
    },
    deleteProperty(target, prop) {
      const prevValue = target[prop];
      const childListeners = prevValue == null ? void 0 : prevValue[LISTENERS];
      if (childListeners) {
        childListeners.delete(popPropListener(prop));
      }
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value) {
      var _a;
      const prevValue = target[prop];
      if (Object.is(prevValue, value)) {
        return true;
      }
      const childListeners = prevValue == null ? void 0 : prevValue[LISTENERS];
      if (childListeners) {
        childListeners.delete(popPropListener(prop));
      }
      if (refSet.has(value) || !isSupportedObject(value) || ((_a = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a.set)) {
        target[prop] = value;
      } else if (value instanceof Promise) {
        target[prop] = value.then((v) => {
          target[prop][PROMISE_RESULT] = v;
          notifyUpdate(["resolve", [prop], v]);
          return v;
        }).catch((e2) => {
          target[prop][PROMISE_ERROR] = e2;
          notifyUpdate(["reject", [prop], e2]);
        });
      } else {
        value = y(value) || value;
        if (value[LISTENERS]) {
          target[prop] = value;
        } else {
          target[prop] = proxy(value);
        }
        target[prop][LISTENERS].add(getPropListener(prop));
      }
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  });
  proxyCache.set(initialObject, proxyObject);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
};
var getVersion = (proxyObject) => {
  if (typeof process === "object" && true && !(proxyObject == null ? void 0 : proxyObject[VERSION])) {
    throw new Error("Please use proxy object");
  }
  return proxyObject[VERSION];
};
var subscribe = (proxyObject, callback, notifyInSync) => {
  if (typeof process === "object" && true && !(proxyObject == null ? void 0 : proxyObject[LISTENERS])) {
    throw new Error("Please use proxy object");
  }
  let pendingVersion = 0;
  const ops = [];
  const listener = (op, nextVersion) => {
    ops.push(op);
    if (notifyInSync) {
      callback(ops.splice(0));
      return;
    }
    pendingVersion = nextVersion;
    Promise.resolve().then(() => {
      if (nextVersion === pendingVersion) {
        callback(ops.splice(0));
      }
    });
  };
  proxyObject[LISTENERS].add(listener);
  return () => {
    proxyObject[LISTENERS].delete(listener);
  };
};
var snapshot = (proxyObject) => {
  if (typeof process === "object" && true && !(proxyObject == null ? void 0 : proxyObject[SNAPSHOT])) {
    throw new Error("Please use proxy object");
  }
  return proxyObject[SNAPSHOT];
};

export {
  i,
  a,
  g,
  ref,
  proxy,
  getVersion,
  subscribe,
  snapshot
};
//# sourceMappingURL=chunk-XOCYC32V.js.map
